= ConventionalModels

Generate ActiveRecord models automatically with basic relationships based on conventions.

== Install

  gem install conventional_models

== Example

We have a table called Page and another called ContentItems (not following ActiveRecord conventions).

  # point active_record to a database
  require 'rubygems'
  require 'active_record'
  ActiveRecord::Base.establish_connection(:database => 'db.sqlite', :adapter => 'sqlite3')
  
  # set your conventions
  require 'conventional_models'
  ConventionalModels.configure do
    primary_key_name "Id"
  end
  
  # use the models
  page = Page.create :Name => 'test'
  page.content_items.create :Name => 'content1'
  
  # have a look at the generated code
  puts Page.model_code
  puts ContentItem.model_code

Output:

  class ::Page < ::ActiveRecord::Base
    set_primary_key "Id"
    set_table_name "Page"
    has_many :content_items, :class_name => 'ContentItem', :primary_key => 'Id', :foreign_key => 'Page_id'
  end
  class ::ContentItem < ::ActiveRecord::Base
    set_primary_key "Id"
    set_table_name "ContentItem"
    belongs_to :page, :class_name => 'Page'
  end

== Default conventions

  ConventionalModels.configure do
    belongs_to_matcher {|column| column.name.end_with? "_id"}
    belongs_to_name {|column| column.name.gsub(/_id$/, "")}
    primary_key_name "id"
    class_name {|table_name| table_name.singularize.camelize}
    ignore_tables "schema_migrations", "sqlite_sequence", "sysdiagrams"
  end

== Note on Patches/Pull Requests
 
* Fork the project.
* Make your feature addition or bug fix.
* Add tests for it. This is important so I don't break it in a
  future version unintentionally.
* Commit, do not mess with rakefile, version, or history.
  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)
* Send me a pull request. Bonus points for topic branches.

== Copyright

Copyright (c) 2010 Steve Hodgkiss. See LICENSE for details.
